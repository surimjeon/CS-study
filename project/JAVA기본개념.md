# [자바] 헷갈리는 기본 개념 정리

### 메소드, 생성자, 필드, 인스턴스, 오버로딩, 오버라이딩, 상속, 접근제한자, 제네릭, 인터페이스, 추상클래스
*질문 참고 : https://gyoogle.dev/blog/interview/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C.html

### 생성자

- 자기자신(필드)를 가르킬때는 this사용하기
- 생성자 : 객체에서 **초기화**를 하기 위해 도와주는 것 (**클래스가 생성될 때, 자동으로 생성해서 가장 먼저 객체**를 초기화하는 역할)
- 생성자 오버로딩: 하나의 클래스에서 매개변수의 개수, 타입 등이 다른 생성자 여러개 선언 가능
    - 매개값으로 객체의 필드를 다양하게 초기화하기 위해 사용
    - 생성자 오버로딩이 많아지면 중복코드가 발생할 수 있는데, 이때는 공통코드를 1개의 생성자에 넣고 나머지는 this를 이용해서 공통코드를 가지고 있는 생성자를 호출할 수 있음
    - 아래처럼, Car 생성자는 model밖에 안받았는데, 다른 생성자를 오버로딩할 수 있다
    - `Car(String model) { this(model,”은색“,250);} Car(String model, String color, int max) { this.model=model; this.color=color; this.max=max; }}`

### 인스턴스

- 소스파일(.java)를 컴파일하면 바이트코드파일(.class)이 되고, 로딩하면 메소드에 들어감
- 메소드는 객체에 소속되어있고(클래스 내의 다른 객체들과 공유할 수 있음), 필드는 객체에 포함되어있다(클래스의 객체마다 가지고 있음)
    - `static 메서드는 메서드 영역에서 저장되어 클래스의 모든 객체들이 공유할 수 있다!`
- 인스턴스에 소속되어있는 필드만 this를 쓸수있다(static은 쓸수없다)

```
Calculator c1 = new Calculator(10,20);
// 인스턴스  = 새로운 생성자(인자)로 만든다
// 이 생성자는 Calculator라는 클래스에서 가장 먼저 실행되는 메소드이다
```

### 메소드

- 오버로딩 : 메소드 이름은 같되, 매개변수의 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것

### 필드

- 클래스의 중괄호 안에 선언된 변수를 '필드' , 메서드의 중괄호 안에 선언된 변수를 '지역변수'로 생각
- 필드는 힙메모리의 객체 내부에, 지역변수는 스택 메모리에 생성(매서드와 필드는 객체에 포함, 메서드>필드x)

### 상속

- class b extends a=a를 상속받겠다, 부모 메서드, 필드를 자식에서 사용가능
- 자식객체를 만들면 자동으로 힙영역에 부모 객체도 만들어진다(부모없는 자식 없듯이) 주소값은 자식 주고를 참고한다
- 어떻게 만들어질까? 자식 클래스 내에 super()가 자동적으로 생겨서 부모 객체가 생성된다(매개변수가 있으면 명시해서 넘겨줌)

### 메소드 오버라이딩(재정의)

- * 오버로딩: 메소드명은 같은데, 매개변수 등을 다르게 지정해서 쓸수있도록 하는 것
- 자식에서 오버라이딩한 메소드는 부모보다 접근제한자를 더 강하게 줄 수 없다 ex)부모에서 default면, 자식에서 private은 해당 메소드에 붙일수없다(디폴트나 public만 가능)
- 컴파일할때 컴파일러에게 이거 내가 오버라이딩한거야(@override)하고 명시해서 오버라이딩의 조건도 만족하는지 검사하게 한다
- 오버라이딩 시 메소드의 모든 줄이 아닌, 일부 줄만 수정하고 싶다면 메소드안에 super.메소드(); 후 일부줄울 수정한다

### Final클래스와 메소드

메소드 오버라이딩 금지, 이 클래스 기반 자식 클래스 사용 금지(부모클래스가 될수없음)

### 접근제한자

- protected : 다른 패키지에 a필드를 Protected를 선언-> 그 필드가 표함된 클래스를 상속받는 자식클래스이라면 그 필드를 사용할 수 있게 해주겠다
- Pulbic>default>protected

![접근제한자](https://blog.kakaocdn.net/dn/LSfh1/btsh6zTfwm8/gmHdhwjS0QEsIdf6MLDuSK/img.png)

### 타입변환

자식객체를 생성한 후에 부모클래스의 객체에 넣으려고 하면 부모타입으로 자동 타입변환이 된다

```
Class B extend A
B b = new B();
A a1=b; // 부모 타입으로 형변환되고, a1은 부모에 정의된 메소드만 쓸수있다
```

(중요!!!)다만, 자식에서 재정의한 메소드가 있으면 오버라이딩한 메소드로 쓰인다

부모가 자식타입으로 변환하려면 다음과 같이 강제 형변환해줘야함

```
A a=new B();
B b= (B) a;
```

### 다형성

사용방법은 동일하지만 실행결과가 다르게 나옴

**다형성은 상속을 사용하고, 자동타입변환+메소드 오버라이딩=다형성**

- 메소드 다형성은 매개변수에 자식객체가 오면서 다형성이 생김

(객체타입확인)

객체가 해당 타입으로 만들어냈는지 참거짓으로 반환, 보통 강제타입변환 전 타입확인을 위해 사용

```
Bus bus=new Bus()
Vehicle v= bus
boolean result= v(객체) instanceof Bus(타입)
```

다형성에서 어떤 타입객체(자식, 부모 등..)이 들어왔는지 알수있음

---

### 추상클래스

- 객체 만들 필요가 없이 공용의 필드 메소드를 쓰기 위해 정의한 클래스
- **단일 상속, 변수를 가질 수 있음, 추상메서드,일반메서드 모두 가질 수 있음**

  ex)동물은 고양이,개 등을 추상적으로 이르는 것 = 동물 추상클래스

- 추상 메서드: 메서드 선언부만 동일하고 실행내용은 자식마다 달라야할때
    - 중괄호 없음(추상메서드는 호출할수없음)
    - 다른 메서드에서 추상메서드를 정의할때는 override해야 함

    ```java
    public abstract class 동물 {
    	abstract void 먹기(); }
    public abstract class 포유류 extends 동물 {
    	abstract void 포유류특징(); }
    
    public class 고양이 extends 포유류 {
    	@override
    	void 먹기() { System.out.print("고양이 먹는다"); }
    	
    	@override
    	void 포유류특징() { System.out.print("고양이 포유류"); }
    
    고양이 obj = new 고양이(); }
    ```


### vs 인터페이스

- interface (사이에 만날 수 있도록 하는 것) : 재정의해야 함
- 관계가 없는 것들을 묶어주는 역할, **다중상속이 가능**
- **변수x, 추상메서드와 상수만 가질 수 있음**

```java
//물에서 생활하는 동물들은 상하관계가 아닌, 
// 형제관계로 볼 수 있는데 이들을 다중으로 묶을 수 있는 것이 물생활 인터페이스
public class 고래 extends 포유류 implements 물생활 {
	@override
	public void 물에서동작() { System.out.print("고래 물생활"); } }
	
```

## 제네릭

- 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것
- 특정(Specific) 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반(Generic) 타입
- <>안에는 참조자료형(클래스, 인터페이스, 배열)만 가능, 기본자료형을 위해서는 wrapper클래스 활용해야함

-> 제네릭을 사용하면 잘못된 타입을 컴파일 단계에서 제한할 수 있음


### Getter, setter

- 값을 가져오면 getter, 값을 세팅하면 setting
- setter는 외부의 값을 검사해서 값을 넣을 수 있도록 함
- getter는 필드에 직접 접근하지 않고 처리 후 내보내고 싶거나 할때 사용
- Private필드를 getter,setter에서 정의해서 사용할 때 사용함. 그래서 다른 클래스에서 이 클래스에 대한 객체를 생성할때도 setter,getter메소드로 값을 접근해야함
- Setter의 return type은 void(값을 변경하기 때문) getter,setter는 public이라는 접근 제한자를 가진다
- 메서드 이름: 필드가 boolean타입일 경우에는 is로 시작, 나머지는 get,set으로 시작한다

### 싱글톤패턴

객체 1개를 만드는 패턴->생성자에 private을 붙이기
